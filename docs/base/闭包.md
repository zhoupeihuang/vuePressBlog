---


---

<h1 id="闭包">闭包</h1>
<p>简单讲，<strong>闭包就是指有权访问另一个函数作用域中的变量的函数。</strong></p>
<p>MY<br>
闭包条件：</p>
<p><strong>1. 外层函数嵌套内层函数；<br>
2. 内层函数引用外层函数中的变量；<br>
3. 外层函数返回内层函数；</strong></p>
<p>MDN 上面这么说：<strong>闭包是一种特殊的对象。</strong></p>
<p>它由两部分构成：<strong>函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。</strong></p>
<p>这种官方的概念是比较难理解的，在面试的时候说出来也不是很专业，因为没办法有个具体的逻辑。</p>
<p>我个人认为，理解闭包的关键在于：<strong>外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象，这就是闭包的重要概念。</strong></p>
<p>作用：<br>
1.扩大变量作用域<br>
2.防止变量变量被销毁（垃圾回收机制）</p>
<pre><code>//看一个闭包运行的例子
function outer(){
    var a=1; //定义内部遍历
    return function(){ //返回a变量值
	    return a;
	}
}
var b = outer();
console.log(b())//1
</code></pre>
<h2 id="产生一个闭包"><strong>产生一个闭包</strong></h2>
<p>创建闭包最常见方式，就是在一个函数内部创建另一个函数。下面例子中的 closure 就是一个闭包：</p>
<pre><code>// 例子
function func(){
    var a= 1;b=2;
    function closure(){ //闭包
    	return a+b 
    	}
	return closure // 返回闭包函数
}
</code></pre>
<p>闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。</p>
<h2 id="闭包的注意事项"><strong>闭包的注意事项</strong></h2>
<p>.通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</p>
<pre><code>function makeAdder(x){
    return function(y){
	    return x+y
	}
}
var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2))//7
console.log(add10(2))//12

add5 = null
add10 = null
</code></pre>
<p>从上述代码可以看到add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。最后通过 null 释放了 add5 和 add10 对闭包的引用。</p>
<p>在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；</p>
<p>如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。</p>
<h2 id="闭包只能取得包含函数中的任何变量的最后一个值"><strong>闭包只能取得包含函数中的****任何变量的最后一个值</strong></h2>
<pre><code>   function arrFunc(){
	var arr = [];
	for(var i=0;i&lt;10;i++){
		arr[i]=function(){
				return i;
			}
	}
	return arr;
}
</code></pre>
<p>大家看一下上面这个代码，arr数组中包含了10个匿名函数，每个匿名函数都能访问外部函数的变量i，那么i是多少呢？</p>
<p>当arrFunc执行完毕后，其作用域被销毁，但它的变量对象仍保存在内存中，得以被匿名访问，这时i的值为9。</p>

